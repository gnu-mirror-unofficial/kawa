<HTML>
<HEAD>
<!-- Created by texi2html 1.56k from /home/bothner/Kawa/kawa/doc/kawa.texi on 26 June 2000 -->

<TITLE>Kawa, the Java-based Scheme system - Compiling Scheme code to byte-codes</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="kawa_1.html">first</A>, <A HREF="kawa_6.html">previous</A>, <A HREF="kawa_8.html">next</A>, <A HREF="kawa_15.html">last</A> section, <A HREF="kawa_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC14" HREF="kawa_toc.html#TOC14">Compiling Scheme code to byte-codes</A></H1>

<P>
All Scheme functions and source files are invisibly compiled
into internal Java byte-codes.
A traditional evaluator is only used for top-level directly entered
expressions <EM>outside</EM> a lambda.  (It would have been simpler
to also byte-compile top-level expressions by surrounding them
by a dummy lambda.  However, this would create a new Class object
in the Java VM for every top-level expression.  This is undesirable
unless you have a VM that can garbage collect Class objects.)


<P>
To save speed when loading large Scheme source files, you probably
want to pre-compile them and save them on your local disk.
There are two ways to do this.


<P>
You can compile a Scheme source file to a single archive file.
You do this using the <CODE>compile-file</CODE> function.
The result is a single file that you can move around and <CODE>load</CODE>
just like the <CODE>.scm</CODE> source file.  You just specify the name
of the archive file to the <CODE>load</CODE> procedure.
Currently, the archive is a "zip" archive and has extension ".zip";
a future release will probably use "Java Archive" (jar) files.
The advantage of compiling to an archive is that it is simple
and transparent.  A minor disadvantage is that it causes the
Java "verifier" to be run when functions are loaded from it,
which takes a little extra time.


<P>
Alternatively, you can compile a Scheme source file to a
collection of <SAMP>`.class'</SAMP> files.
You then use the standard Java class loading mechanism to load the code.
The Java "verifier" does not need to get run, which makes
loading a little faster.
The compiled class files do have to be installed be installed somewhere
in the <CODE>CLASSPATH</CODE>.



<UL>
<LI><A HREF="kawa_7.html#SEC15">Archive compilation</A>: Compiling Scheme to an archive file
<LI><A HREF="kawa_7.html#SEC16">Files compilation</A>: Compiling Scheme to a set of .class files
<LI><A HREF="kawa_7.html#SEC17">Application compilation</A>: Compiling Scheme to a standalone application
<LI><A HREF="kawa_7.html#SEC18">Applet compilation</A>: Compiling Scheme to an applet
</UL>



<H2><A NAME="SEC15" HREF="kawa_toc.html#TOC15">Compiling Scheme to an archive file</A></H2>

<P>
To byte-compile a file <SAMP>`foo.scm'</SAMP> do:

<PRE>
(compile-file "foo.scm" "foo")
</PRE>

<P>
This will create <SAMP>`foo.zip'</SAMP>, which contains byte-compiled "j-code"
that implements <SAMP>`foo.scm'</SAMP>.


<P>
You can later do:

<PRE>
(load "foo")
</PRE>

<P>
This will load <SAMP>`foo.zip'</SAMP>, which should have the same effect as
loading <SAMP>`foo.scm'</SAMP>, except you will get the byte-compiled versions.




<H2><A NAME="SEC16" HREF="kawa_toc.html#TOC16">Compiling Scheme to a set of .class files</A></H2>

<P>
Invoking <SAMP>`kawa'</SAMP> (or <SAMP>`java kawa.repl'</SAMP>) with
the <SAMP>`-C'</SAMP> flag will compile
a <SAMP>`.scm'</SAMP> source file into one or more <SAMP>`.class'</SAMP> files.


<P>
You run it as follows:

<PRE>
kawa [-d <VAR>outdirectory</VAR>] [-P <VAR>prefix</VAR>] [-T <VAR>topname</VAR>] [--main | --spplet] -C <VAR>infile</VAR> ...
</PRE>

<P>
Note the <SAMP>`-C'</SAMP> must come last, because <SAMP>`Kawa'</SAMP> processes the
arguments and options in order,


<P>
Here:
<DL COMPACT>

<DT><SAMP>`-C <VAR>infile</VAR> ...'</SAMP>
<DD>
The Scheme source files we want to compile.
<DT><SAMP>`-d <VAR>outdirectory</VAR>'</SAMP>
<DD>
The directory under which the resulting <SAMP>`.class'</SAMP> files will be.
The default is the current directory.
<DT><SAMP>`-P <VAR>prefix</VAR>'</SAMP>
<DD>
A string to prepend to the generated class names.
The default is the empty string.
<DT><SAMP>`-T <VAR>topname</VAR>'</SAMP>
<DD>
The name of the "top" class - i.e. the one that contains the code
for the top-level expressions and definitions.
The default is generated from the <VAR>infile</VAR> and <VAR>prefix</VAR>.
<DT><SAMP>`--main'</SAMP>
<DD>
Generate a <CODE>main</CODE> method so that the resulting "top" class can
be used as a stand-alone application. See section <A HREF="kawa_7.html#SEC17">Compiling Scheme to a standalone application</A>.
<DT><SAMP>`--applet'</SAMP>
<DD>
The resulting class inherits from <CODE>java.applet.Applet</CODE>,
and can be used as an applet.  See section <A HREF="kawa_7.html#SEC18">Compiling Scheme to an applet</A>.
<DT><SAMP>`--module-static'</SAMP>
<DD>
If no <CODE>module-static</CODE> is specified, generate a static module
(as if <CODE>(module-static #t)</CODE> were specified. See section <A HREF="kawa_10.html#SEC57">Modules and how they are compiled to classes</A>.
</DL>

<P>
When you actually want to load the classes, the <VAR>outdirectory</VAR>
must be in your <SAMP>`CLASSPATH'</SAMP>.
You can use the standard <CODE>load</CODE> function to load the code,
by specifying the top-level class, either as a file name
(relative to <VAR>outdirectory</VAR>) or a class name.
E.g. if you did:

<PRE>
kawa -d /usr/local/share/java -P my.lib. -T foo -C foosrc.scm
</PRE>

<P>
you can use either:

<PRE>
(load "my.lib.foo")
</PRE>

<P>
or:

<PRE>
(load "my/lib/foo.class")
</PRE>

<P>
If you are compiling a Scheme source file (say <SAMP>`foosrc.scm'</SAMP>)
that uses macros defined in some other file (say <SAMP>`macs.scm'</SAMP>),
you need to make sure the definitions are visible to the compiler.
One way to do that is with the <SAMP>`-f'</SAMP>:

<PRE>
kawa -f macs.scm -C foosrc.scm
</PRE>



<H2><A NAME="SEC17" HREF="kawa_toc.html#TOC17">Compiling Scheme to a standalone application</A></H2>

<P>
A Java application is a Java class with a special method
(whose name is <CODE>main</CODE>).  The application can be invoked directly
by naming it in the Java command.
If you want to generate an application from a Scheme program,
create a Scheme source file with the definitions you need, plus
the top-level actions that you want the application to execute.
You can compile in the regular way decribed in the previous section, but add
the <CODE>--main</CODE> option.  For example,
assuming your Scheme file is <CODE>MyProgram.scm</CODE>:

<PRE>
kawa --main -C MyProgram.scm
</PRE>

<P>
This will create a <CODE>MyProgram.class</CODE> which you can either <CODE>load</CODE>
(as decribed in the previous section), or invoke as an application:

<PRE>
java MyProgram [<VAR>args</VAR>]
</PRE>

<P>
Your Scheme program can access the command-line arguments <VAR>args</VAR>
by using the global variable <SAMP>`command-line-arguments'</SAMP>.




<H2><A NAME="SEC18" HREF="kawa_toc.html#TOC18">Compiling Scheme to an applet</A></H2>
<P>
An applet is a Java class that inherits from <CODE>java.applet.Applet</CODE>.
The applet can be downloaded and run in a Java-capable web-browser.
To generate an applet from a Scheme program, write the Scheme
program with appropriate definitions of the functions <SAMP>`init'</SAMP>,
<SAMP>`start'</SAMP>, <SAMP>`stop'</SAMP> and <SAMP>`destroy'</SAMP>.  You must declare these
as zero-argument functions with a <CODE>&#60;void&#62;</CODE> return-type.


<P>
Here is an example, based on the scribble applet in Flanagan's
"Java Examples in a Nutshell" (O'Reilly, 1997):

<PRE>
(define-private last-x 0)
(define-private last-y 0)

(define (init) &#60;void&#62;
  (let ((applet :: &#60;java.applet.Applet&#62; (this)))
    (invoke applet 'addMouseListener
	    (object (&#60;java.awt.event.MouseAdapter&#62;)
		    ((mousePressed (e :: &#60;java.awt.event.MouseEvent&#62;)) &#60;void&#62;
		     (set! last-x (invoke e 'getX))
		     (set! last-y (invoke e 'getY)))))
    (invoke applet 'addMouseMotionListener
	    (object (&#60;java.awt.event.MouseMotionAdapter&#62;)
		    ((mouseDragged (e :: &#60;java.awt.event.MouseEvent&#62;)) &#60;void&#62;
		     (let ((g :: &#60;java.awt.Graphics&#62;
			      (invoke applet 'getGraphics))
			   (x :: &#60;int&#62; (invoke e 'getX))
			   (y :: &#60;int&#62; (invoke e 'getY)))
		       (invoke g 'drawLine last-x last-y x y)
		       (set! last-x x)
		       (set! last-y y)))))))

(define (start) &#60;void&#62; (format #t "called start.~%~!"))
(define (stop) &#60;void&#62; (format #t "called stop.~%~!"))
(define (destroy) &#60;void&#62; (format #t "called destroy.~%~!"))
</PRE>

<P>
You compile the program with the <SAMP>`--applet'</SAMP> flag in addition to the
normal <SAMP>`-C'</SAMP> flag:

<PRE>
java kawa.repl --applet -C scribble.scm
</PRE>

<P>
You can then create a <SAMP>`.jar'</SAMP> archive containing your applet.
You also need to include the Kawa classes in the <SAMP>`.jar'</SAMP>,
or you can include a <CODE>MANIFEST</CODE> file that specifies <CODE>Class-Path</CODE>
to use a Java 2
<A HREF="http://java.sun.com/docs/books/tutorial/ext/basics/download.html">download extension</A>.

<PRE>
jar cf scribble.jar scribble*.class <I>other-classes ...</I>
</PRE>

<P>
Finally, you create an <SAMP>`.html'</SAMP> page referencing your applet:

<PRE>
&#60;html&#62;&#60;head&#62;&#60;title&#62;Scribble testapp&#60;/title&#62;&#60;/head&#62;
&#60;body&#62;&#60;h1&#62;Scribble testapp&#60;/h1&#62;
You can scribble here:
&#60;br&#62;
&#60;applet code="scribble.class" archive="scribble.jar" width=200 height=200&#62;
Sorry, Java is needed.&#60;/applet&#62;
&#60;/body&#62;&#60;/html&#62;
</PRE>

<P><HR><P>
Go to the <A HREF="kawa_1.html">first</A>, <A HREF="kawa_6.html">previous</A>, <A HREF="kawa_8.html">next</A>, <A HREF="kawa_15.html">last</A> section, <A HREF="kawa_toc.html">table of contents</A>.
</BODY>
</HTML>
